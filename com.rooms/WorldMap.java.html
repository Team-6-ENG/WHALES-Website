<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WorldMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tests</a> &gt; <a href="index.source.html" class="el_package">com.rooms</a> &gt; <span class="el_source">WorldMap.java</span></div><h1>WorldMap.java</h1><pre class="source lang-java linenums">package com.rooms;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g3d.Renderable;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Json;
import com.badlogic.mazegame.Main;
import com.events.Obstacle;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

/** Represents the map. */
public class WorldMap extends Renderable {

  // Changed: store path in constant for testing
  public static final String FALLBACK_IMG = &quot;rooms/Fallback.png&quot;;
  public static final String MAP = &quot;map.json&quot;;
  public static final String COIN_IMG = &quot;items/coin.png&quot;;
  // Changed 22/12/2025 ensure always boundary to the sides of the tiles for UI
  public static final int BOUNDARY_WIDTH = 6;

  /** The size of each room on the screen. */
<span class="fc" id="L30">  public static final int ROOM_SIZE =</span>
<span class="fc" id="L31">      Math.min(Main.WORLD_HEIGHT, Main.WORLD_WIDTH - (BOUNDARY_WIDTH * 2));</span>

  /** The centre of the room . */
<span class="fc" id="L34">  public static final Vector2 centrePosition =</span>
      new Vector2(Main.WORLD_WIDTH / 2f, Main.WORLD_HEIGHT / 2f);

<span class="fc" id="L37">  public static HashMap&lt;String, Rectangle&gt; currentBricks = new HashMap&lt;&gt;();</span>

  /** Currently loaded obstacles. */
  private final Collection&lt;Obstacle&gt; obstacles;

<span class="fc" id="L42">  private final HashMap&lt;String, Rectangle&gt; bricks = new HashMap&lt;&gt;();</span>
<span class="fc" id="L43">  public HashMap&lt;String, Vector2&gt; coins = new HashMap&lt;&gt;();</span>

  /** Mapping of room name, e.g. &quot;MainPath2&quot; to a Room object . */
  private Map&lt;String, JsonRoom&gt; locations;

  /** The currently loaded room . */
  private String currentLocation;

  /** The previously loaded room (added 17/12/25) . */
  private String previousLocation;

  /** The sprite containing the currently loaded rooms texture. */
  private Sprite roomSprite;

  /**
   * Constructs a new instance of the game map.
   *
   * @param startLocation The name of the room to start in
   */
<span class="fc" id="L62">  public WorldMap(String startLocation) {</span>
<span class="fc" id="L63">    loadMap();</span>
<span class="fc" id="L64">    obstacles = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L65">    this.currentLocation = startLocation;</span>
<span class="fc" id="L66">    this.previousLocation = currentLocation;</span>
<span class="fc" id="L67">    loadRoomSprite(currentLocation);</span>

<span class="fc" id="L69">    bricks.put(</span>
        &quot;left&quot;,
        new Rectangle(
            (float) (Main.WORLD_WIDTH - ROOM_SIZE) / 2,
            (float) (Main.WORLD_HEIGHT - ROOM_SIZE) / 2,
            1 / 2f,
            ROOM_SIZE));
<span class="fc" id="L76">    bricks.put(</span>
        &quot;right&quot;,
        new Rectangle(
            (float) (Main.WORLD_WIDTH + ROOM_SIZE - 1) / 2,
            (float) (Main.WORLD_HEIGHT - ROOM_SIZE) / 2,
            1 / 2f,
            ROOM_SIZE));
<span class="fc" id="L83">    bricks.put(</span>
        &quot;up&quot;,
        new Rectangle(
            (float) (Main.WORLD_WIDTH - ROOM_SIZE) / 2,
            (float) (Main.WORLD_HEIGHT + ROOM_SIZE - 1) / 2,
            ROOM_SIZE,
            1 / 2f));
<span class="fc" id="L90">    bricks.put(</span>
        &quot;down&quot;,
        new Rectangle(
            (float) (Main.WORLD_WIDTH - ROOM_SIZE) / 2,
            (float) (Main.WORLD_HEIGHT - ROOM_SIZE) / 2,
            ROOM_SIZE,
            1 / 2f));
<span class="fc" id="L97">  }</span>

  /** Load the map from a JSON file . */
  @SuppressWarnings(&quot;unchecked&quot;)
  private void loadMap() {
<span class="fc" id="L102">    String file = Gdx.files.internal(MAP).readString();</span>

<span class="fc" id="L104">    Json json = new Json();</span>
<span class="fc" id="L105">    locations =</span>
<span class="fc" id="L106">        json.fromJson(HashMap.class, JsonRoom.class, file); // reads a JSON object into a Hashmap</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">    for (String location : locations.keySet()) {</span>
<span class="fc" id="L109">      Random r = new Random();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">      if (r.nextInt(2) == 1) {</span>
<span class="fc" id="L111">        coins.put(</span>
            location,
            new Vector2(
<span class="fc" id="L114">                r.nextInt((Main.WORLD_WIDTH - ROOM_SIZE) / 2, (Main.WORLD_WIDTH + ROOM_SIZE) / 2),</span>
<span class="fc" id="L115">                r.nextInt((Main.WORLD_WIDTH - ROOM_SIZE) / 2, (Main.WORLD_WIDTH + ROOM_SIZE) / 2)));</span>
      }
<span class="fc" id="L117">    }</span>
<span class="fc" id="L118">  }</span>

  /**
   * Get the room associated with a given room name.
   *
   * @param name The name of the room to fetch
   * @return The room associated with the given name, or null if none exists
   */
  public JsonRoom getLocation(String name) {
<span class="nc" id="L127">    return locations.get(name);</span>
  }

  /**
   * Check if a room with a given name exists.
   *
   * @param name The name of the room to check
   * @return A boolean value representing whether the room exists
   */
  public boolean hasLocation(String name) {
<span class="fc" id="L137">    return locations.containsKey(name);</span>
  }

  /**
   * Get all location in Map.
   *
   * @return The full mapping from room names to rooms
   */
  public Map&lt;String, JsonRoom&gt; getAllLocations() {
<span class="fc" id="L146">    return locations;</span>
  }

  /**
   * Get current location of player.
   *
   * @return The currently active room
   */
  public String getCurrentLocation() {
<span class="fc" id="L155">    return currentLocation;</span>
  }

  /**
   * Get previous location of player.
   *
   * @return The previously active room
   */
  public String getPreviousLocation() {
<span class="fc" id="L164">    return previousLocation;</span>
  }

  /**
   * Get obstacles in current room.
   *
   * @return All active obstacles for the current room
   */
  public Collection&lt;Obstacle&gt; getObstacles() {
<span class="fc" id="L173">    return obstacles;</span>
  }

  /** Remove coin from room once collected. */
  public void removeCoinFromObstacles() {
<span class="nc" id="L178">    obstacles.removeIf(obstacle -&gt; obstacle.getTextureInternalPath().equals(COIN_IMG));</span>
<span class="nc" id="L179">  }</span>

  /**
   * Load the room in a given direction.
   *
   * @param direction The direction to move in
   * @return &lt;code&gt;true&lt;/code&gt; if moving succeeded, &lt;code&gt;false&lt;/code&gt; otherwise. This may fail if
   *     no room exists in this direction.
   */
  public boolean move(OrthogonalDirection direction) {
<span class="fc" id="L189">    JsonRoom current = locations.get(currentLocation);</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">    if (current == null) {</span>
<span class="nc" id="L191">      return false;</span>
    }
<span class="fc" id="L193">    String next = current.getNext(direction);</span>
<span class="pc bpc" id="L194" title="1 of 4 branches missed.">    if (next != null &amp;&amp; locations.containsKey(next)) { // only allows movement to pointed Nodes</span>
<span class="fc" id="L195">      System.out.println(&quot;Moving to room &quot; + next);</span>
<span class="fc" id="L196">      System.out.println(locations.get(next).toString());</span>
<span class="fc" id="L197">      previousLocation = currentLocation;</span>
<span class="fc" id="L198">      currentLocation = next; // &quot;moves&quot; to new Room</span>
<span class="fc" id="L199">      loadRoomSprite(next);</span>
<span class="fc" id="L200">      return true;</span>
    }
<span class="fc" id="L202">    return false;</span>
  }

  /**
   * Load the texture associated with the given room name.
   *
   * @param roomName The name of the room whose texture to load
   */
  private void loadRoomSprite(String roomName) {
<span class="fc" id="L211">    String filename = &quot;rooms/&quot; + roomName + &quot;.png&quot;;</span>

    // Check if the file exists
<span class="fc bfc" id="L214" title="All 2 branches covered.">    if (!Gdx.files.internal(filename).exists()) {</span>
      // Use fallback if it doesn't
<span class="fc" id="L216">      System.out.println(&quot;No texture found for this room: &quot; + roomName);</span>
<span class="fc" id="L217">      filename = FALLBACK_IMG;</span>
    }
<span class="fc" id="L219">    System.out.println(&quot;Loading room texture: &quot; + filename);</span>
    // Create texture and sprite
<span class="fc" id="L221">    Texture roomTexture = new Texture(filename);</span>
<span class="fc" id="L222">    roomSprite = new Sprite(roomTexture);</span>
    // Resize and position
<span class="fc" id="L224">    roomSprite.setSize(ROOM_SIZE, ROOM_SIZE);</span>
<span class="fc" id="L225">    Rectangle rect = roomSprite.getBoundingRectangle().setCenter(centrePosition);</span>
<span class="fc" id="L226">    roomSprite.setPosition(rect.x, rect.y);</span>

    // Load room obstacles
<span class="fc" id="L229">    obstacles.clear();</span>
<span class="fc" id="L230">    JsonObstacle[] jsonObstacles = locations.get(roomName).obstacles;</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">    if (!(jsonObstacles == null)) {</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">      for (int i = jsonObstacles.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L233">        JsonObstacle obst = jsonObstacles[i];</span>
<span class="fc" id="L234">        obstacles.add(</span>
            new Obstacle(
                obst.obstacleX, obst.obstacleY, obst.width, obst.height, obst.textureInternalPath));
      }
    }

<span class="fc bfc" id="L240" title="All 2 branches covered.">    if (coins.containsKey(roomName)) {</span>
<span class="fc" id="L241">      obstacles.add(new Obstacle(coins.get(roomName).x, coins.get(roomName).y, 1, 1, COIN_IMG));</span>
    }
<span class="fc" id="L243">    constructBorderObstacles();</span>
<span class="fc" id="L244">    System.out.println(obstacles.size());</span>
<span class="fc" id="L245">  }</span>

  /**
   * Get room position.
   *
   * @return The coordinates of the bottom left corner of the room
   */
  public Vector2 getPosition() {
<span class="fc" id="L253">    return new Vector2(roomSprite.getX(), roomSprite.getY());</span>
  }

  /**
   * Render the player to the screen.
   *
   * @param batch The SpriteBatch to render to
   */
  public void render(SpriteBatch batch) {
<span class="nc bnc" id="L262" title="All 2 branches missed.">    if (roomSprite == null) {</span>
<span class="nc" id="L263">      return;</span>
    }
<span class="nc" id="L265">    roomSprite.draw(batch);</span>
<span class="nc" id="L266">  }</span>

  /**
   * Construct obstacles to border the room and stop the player leaving the play area. These are
   * added to the collection of obstacles for the room.
   */
  private void constructBorderObstacles() {
<span class="fc" id="L273">    float height = Main.WORLD_HEIGHT;</span>
<span class="fc" id="L274">    float width = Main.WORLD_WIDTH;</span>

    // Thickness of border (how “wide” each obstacle is)
<span class="fc" id="L277">    float borderThickness = 1f;</span>

    // Create 4 obstacles that form borders around the screen
<span class="fc" id="L280">    Vector2 mapBottomLeft = this.getPosition();</span>
<span class="fc" id="L281">    Vector2 mapTopRight =</span>
        new Vector2(mapBottomLeft.x + WorldMap.ROOM_SIZE, mapBottomLeft.y + WorldMap.ROOM_SIZE);
    // +0.2s and -0.2s force the border to be offset slightly from the room, so that room
    // transitions still function.
    // Bottom border
<span class="fc" id="L286">    Obstacle bottomBorder =</span>
        new Obstacle(
            mapBottomLeft.x, mapBottomLeft.y - borderThickness - 0.2f, width, borderThickness);
    // Top border
<span class="fc" id="L290">    Obstacle topBorder =</span>
        new Obstacle(mapBottomLeft.x, mapTopRight.y + 0.2f, width, borderThickness);
    // Left border
<span class="fc" id="L293">    Obstacle leftBorder =</span>
        new Obstacle(
            mapBottomLeft.x - borderThickness - 0.2f, mapBottomLeft.y, borderThickness, height);

    // Make the obstacles solid
<span class="fc" id="L298">    bottomBorder.setSolid(true);</span>
<span class="fc" id="L299">    topBorder.setSolid(true);</span>
<span class="fc" id="L300">    leftBorder.setSolid(true); // Right border</span>
<span class="fc" id="L301">    Obstacle rightBorder =</span>
        new Obstacle(mapTopRight.x + 0.2f, mapBottomLeft.y, borderThickness, height);

<span class="fc" id="L304">    rightBorder.setSolid(true);</span>

    // Store all obstacles
<span class="fc" id="L307">    obstacles.add(bottomBorder);</span>
<span class="fc" id="L308">    obstacles.add(topBorder);</span>
<span class="fc" id="L309">    obstacles.add(leftBorder);</span>
<span class="fc" id="L310">    obstacles.add(rightBorder);</span>

<span class="fc" id="L312">    currentBricks = new HashMap&lt;&gt;(bricks);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">    for (OrthogonalDirection direction : OrthogonalDirection.values()) {</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">      if (locations.get(currentLocation).getNext(direction) != null) {</span>
<span class="fc" id="L315">        currentBricks.remove(direction.toString());</span>
      }
    }
<span class="fc" id="L318">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>